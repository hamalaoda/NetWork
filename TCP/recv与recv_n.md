# recv_n函数：

```c
void recv_n(int sock, void *buf, int len) 
{    
    int total = 0;    
    while (total < len) 
    {        
        int n = recv(sock, (char*)buf + total, len - total, 0);        
        if (n <= 0) 
        {            
            perror("recv");            
            exit(1);        
        }        
        total += n;    
    }
}
```

recv_n函数通过多次调用recv函数达到一次读完期望字节的数据。

## 函数作用：

**从一个网络连接中精确地接收 `len` 字节的数据，并将其存储到 `buf` 指向的缓冲区中”**。

## 函数解析：

- **`void`**: 返回类型为 `void`，意味着这个函数不直接返回任何值。它的成功与否通过是否正常返回体现，失败则直接终止程序。
- **`int sock`**: 第一个参数是 `sock`，它是一个**文件描述符**（File Descriptor），代表一个已经建立好的网络套接字（Socket）。`recv` 函数通过它来识别要从哪个网络连接接收数据。
- **`void \*buf`**: 第二个参数是 `buf`，它是一个 `void *`（通用指针），指向一块内存区域。函数接收的数据将被复制到这块内存中。使用 `void *` 是为了让函数可以接收任何类型的数据（比如 `char`、`int`、自定义结构体等）的缓冲区地址，增强了函数的通用性。
- **`int len`**: 第三个参数是 `len`，它是一个整数，表示**期望接收的总字节数**。
- `(char*)buf + total`: 这是本次 `recv` 调用要写入数据的**缓冲区起始地址**。
- 这是对 `recv` 返回值 `n` 的检查，非常重要。
  - 如果 `n > 0`：表示成功接收了 `n` 字节的数据。
  - 如果 `n == 0`：表示**对方主动关闭了连接**（在 TCP 中，收到 FIN 包）。这是一个正常的关闭事件，但对于期望接收 `len` 字节的 `recv_n` 函数来说，这意味着数据不完整，是一个错误。
  - 如果 `n < 0`：表示发生了**错误**。最常见的错误是 `EINTR`（被信号中断）

# 接收缓冲区：

客户端发来的数据会先到达内核的接收缓冲区

# recv函数：

### 函数特点：

- 它会尽力从内核的接收缓冲区中读取数据。
- 它返回的实际读取字节数 (`n`) 可能**小于**你请求的字节数 (`len - total`)。
- 这种情况发生的典型原因包括：
  1. **TCP 拆包**：对方发送的数据较大，被 TCP 协议栈拆分成了多个 TCP 段（Segment）分批发送。你的`recv`调用可能在第一个段到达后就被唤醒，此时只能读到部分数据。
  2. **应用层读取不及时**：内核缓冲区中可能已经有了一些数据（比如上一次接收的粘包数据），`recv` 会先返回这些数据，而不会等待你要求的 `len` 字节全部到达。

###  **与内核缓冲区的关系**

- 操作系统为每个套接字维护一个 **接收缓冲区**（内核空间）。
- 当网络数据到达时，TCP 协议栈会将数据存入该缓冲区，并重组为连续的字节流。
- `recv` 的作用是从内核缓冲区中 **复制** 数据到应用层的 `buf` 中。
- 如果内核缓冲区中没有数据，`recv` 会阻塞（默认模式），直到有数据到达或连接关闭。

# 区别：

| 特性             | `recv` (系统调用)                                            | `recv_n` (自定义函数)                                        |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **核心目标**     | 从内核缓冲区读取 “尽可能多” 的数据，但不保证读完。           | 精确地读取指定长度（`len`）的字节数据。                      |
| **返回值含义**   | 返回实际读取到的字节数（可能小于请求的长度）。               | 成功则无返回值（或返回`void`），失败则直接终止程序或返回错误码。 |
| **数据完整性**   | **不保证**。可能只返回部分数据，需要调用者自行处理。         | **保证**。要么收到完整的 `len` 字节，要么函数就不会返回（在阻塞模式下）。 |
| **处理方式**     | 单次调用，立即返回。                                         | 在一个 `while` 循环中**反复调用 `recv`**，直到收满所需数据。 |
| **错误处理**     | 返回 `-1`，并设置 `errno`，由调用者决定如何处理（重试、忽略、退出等）。 | 内部捕获错误（如 `recv` 返回 `<=0`），通常直接调用 `perror` 打印错误信息并 `exit(1)` 终止程序。 |
| **适用场景**     | 底层网络编程，需要灵活控制接收过程。例如，在非阻塞 I/O 模型中，需要根据返回值判断是数据可读、无数据还是出错。 | 应用层需要接收固定长度数据的场景。例如：- 读取一个固定大小的协议头部。- 接收一个已知长度的文件块。- 确保收到一个完整的结构体。 |
| **与协议的关系** | 仅关注字节流，不理解应用层协议。                             | 体现了应用层协议的需求（即 “我需要接收一个长度为`len`的消息”）。 |

send与send_n类似